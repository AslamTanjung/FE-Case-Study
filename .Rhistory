ts_close <- xts(data_close$PRICE, data_close$DATE_TIME)
ts_open
glimpse(data)
data <- data %>%
mutate(PRICE = as.numeric(PRICE))
data
glimpse(dta)
glimpse(data)
## Make open and close data
data_open <- data %>%
group_by(DATE) %>%
slice_head(n = 1)
data_close <- data %>%
group_by(DATE) %>%
slice_tail(n = 1)
ts_open <- xts(data_open$PRICE, data_open$DATE_TIME)
ts_close <- xts(data_close$PRICE, data_close$DATE_TIME)
ts_open
ts <- rollapply(ts_open$PRICE, FUN=f, width=hold+1, align="left", na.pad=T)
f <- function(x) log(tail(x, 1)) - log(head(x, 1))
ts <- rollapply(ts_open$PRICE, FUN=f, width=hold+1, align="left", na.pad=T)
?rollapply
require(TTR)
ts_open_return <- ROC(ts_open$PRICE, n = 1)
ts_open
ts_open_return <- ROC(ts_open, n = 1)
ts_open_return
ret_open[1:2]
ret_open <- ROC(ts_open, n = 1)
ret_open[1:2]
ts_open[1:2]
ret_close <- ROC(ts_close, n = 1)
library(rugarch)
install.packages('rugarch')
ret_open_mom <- momentum(ts_open, n = 1)
ret_open_mom[1:5]
ret_open[1:5]
ts_open[1:5]
col(ret_open)
names(ret_open)
glimpse(ret_open)
p1 <- ggplot(ret_open, aes(x=ret_open.index, y=ret_open)) + geom_line(colour="steelblue")
library(ggplot2)
p1 <- ggplot(ret_open, aes(x=ret_open.index, y=ret_open)) + geom_line(colour="steelblue")
p1
ret_open
ret_open
ret_open.index
index(ret_open)
plot(index(ret_open), ret_open)
plot(index(ret_open), ret_open, type = "l")
plot(index(ret_open), ret_open, type = "l",xlab = "Time", ylab = "Return", title = "Open Prices Returns")
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open Return")
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Close Return")
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open Return")
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Close Return")
ts <- xts(data$PRICE, data$DATE_TIME)
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "seconds", alignPeriod = 5, makeReturns = TRUE, kernelType = "Parzen")
kernel_cov
fit = ugarchfit(spec, ret_close * 100, solver = 'hybrid', realizedVol = kernel_cov * 100)
library(rugarch)
##
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)))
fit <- ugarchfit(spec, ret_close * 100, solver = 'hybrid', realizedVol = kernel_cov * 100)
str(ret_close)
str(kernel_cov)
names(kernel-cov)
names(kernel_cov)
kernel_cov[,1]
fit <- ugarchfit(spec, ret_close * 100, solver = 'hybrid', realizedVol = kernel_cov[,1] * 100)
ret_close$
f
kernel_cov$r
kernel_cov$lidjfa
ret_close
str(ret_close)
str(kernel_cov)
fit <- ugarchfit(spec, ret_close[1:len(ret_close)] * 100, solver = 'hybrid', realizedVol = kernel_cov[1:len(kernel_cov)] * 100)
fit <- ugarchfit(spec, ret_close[1:length(ret_close)] * 100, solver = 'hybrid', realizedVol = kernel_cov[1:length(kernel_cov)] * 100)
fit <- ugarchfit(spec, ret_close[2:length(ret_close)] * 100, solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)] * 100)
fit
##
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
fit <- ugarchfit(spec, ret_close[2:length(ret_close)] * 100, solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)] * 100)
##
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
fit <- ugarchfit(spec, log(ret_close[2:length(ret_close)]) * 100, solver = 'hybrid', realizedVol = log(kernel_cov[2:length(kernel_cov)]) * 100)
## Make returns
## LOG return
ret_open <- momentum(log(ts_open), n = 1)
ret_close <- momentum(log(ts_close), n = 1)
ret_close <- momentum(log(ts_close), n = 1)
## Make returns
## LOG return
ret_open <- momentum(log(ts_open), n = 1)
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open Return")
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Close Return")
##
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
fit <- ugarchfit(spec, ret_close[2:length(ret_close)] * 100, solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)] * 100)
fit
## Make returns
## LOG return
ret_open <- momentum(100 * log(ts_open), n = 1)
ret_close <- momentum(100 * log(ts_close), n = 1)
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open Return")
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Close Return")
##
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
fit <- ugarchfit(spec, ret_close[2:length(ret_close)], solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)])
print(fit)
#ret_close <- momentum(100 * log(ts_close), n = 1)
ret_open_close <- 100 *(log(ts_open) - log(ts_close))
ret_open_close
log(ts_open)
#ret_close <- momentum(100 * log(ts_close), n = 1)
ret_open_close <- 100 *(log(ts_open) - log(ts_close))
ret_open_close
log(ts_open) - log(ts_close)
#ret_close <- momentum(100 * log(ts_close), n = 1)
ret_open_close <- 100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))
#ret_close <- momentum(100 * log(ts_close), n = 1)
ret_open_close <- 100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close)))
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open Return")
#ret_close <- momentum(100 * log(ts_close), n = 1)
ret_open_close <- 100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close)))
ret_open_close
#ret_close <- momentum(100 * log(ts_close), n = 1)
ret_open_close <- xts(100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))), index(ts_close))
ret_open_close
## Make returns
## LOG return
ret_open <- momentum(100 * log(ts_open), n = 1)
#ret_close <- momentum(100 * log(ts_close), n = 1)
ret_open_close <- xts(100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))), index(ts_close))
#ret_close <- momentum(100 * log(ts_close), n = 1)
ret_oc <- xts(100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))), index(ts_close))
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close Return")
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "seconds", alignPeriod = 1, makeReturns = TRUE, kernelType = "Parzen")
write.table(ret_close, file = "Close_to_close_log_returns.csv")
write.table(ret_oc, file = "Open_to_close_log_returns.csv")
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 1, makeReturns = FALSE, kernelType = "Parzen")
## Realized volatility
cov <- rCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 1, makeReturns = TRUE)
warnings()
ts <- xts(data$PRICE, data$DATE_TIME)
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 1, makeReturns = FALSE, kernelType = "Parzen")
data
ts
kernel_cov
length(kernel_cov)
length(cov)
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 5, makeReturns = FALSE, kernelType = "Parzen")
## Realized volatility
cov <- rCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 5, makeReturns = TRUE)
## Realized volatility
cov <- rCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 20, makeReturns = TRUE)
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 20, makeReturns = FALSE, kernelType = "Parzen")
ret_close <- read.csv("Close_to_close_log_returns.csv")
ret_close
## Make returns
## LOG return
ret_close <- momentum(100 * log(ts_close), n = 1)
ret_oc <- xts(100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))), index(ts_close))
ret_close
write.table
write.table(ret_close, file = "Close_to_close_log_returns.csv", row.names = TRUE)
ret_close
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", row.names = TRUE)
write.zoo(ret_oc, file = "Open_to_close_log_returns.csv", row.names = TRUE)
plot(kernel_cov-cov)
## Realized
plot(kernel_cov, col = 'green')
lines(cov, col = 'red')
plot(kernel_cov-cov)
## Realized
plot(kernel_cov, col = 'green')
## Realized
plot(kernel_cov, col = 'green')
lines(cov, col = 'red')
## Realized
plot(kernel_cov, col = 'blue')
lines(cov, col = 'red')
## Realized
plot(cov, col = 'blue')
## Realized
plot(cov, col = 'red')
lines(cov, col = 'blue')
lines(kernel_cov, col = 'blue')
## Realized
plot(cov, col = 'red')
lines(kernel_cov, col = 'blue')
plot(kernel_cov-cov)
## Realized
plot(cov, col = 'red')
lines(kernel_cov, col = 'blue')
## Realized
plot(cov, col = 'red')
lines(kernel_cov, col = 'blue')
kernel_cov - cov
plot(kernel_cov-cov)
lines(kernel_cov, col = 'blue')
## Realized
plot(cov, col = 'red')
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 20, makeReturns = FALSE, kernelType = "Parzen")
## Realized volatility
cov <- rCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 20, makeReturns = TRUE)
## Realized
plot(cov, col = 'red')
lines(kernel_cov, col = 'blue')
plot(kernel_cov-cov)
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 20, makeReturns = TRUE, kernelType = "Parzen")
## Realized volatility
cov <- rCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 20, makeReturns = TRUE)
## Realized
plot(cov, col = 'red')
lines(kernel_cov, col = 'blue')
ret_oc <- read.csv("Open_to_close_log_returns.csv")
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close Return")
ret_close <- read.csv("Close_to_close_log_returns.csv")
ret_oc <- read.csv("Open_to_close_log_returns.csv")
ret_close
write.zoo(ret_close, file = "Close_to_close_log_returns.csv")
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", row.names = TRUE, col.names = TRUE)
ret_close
## Make returns
## LOG return
ret_close <- momentum(100 * log(ts_close), n = 1)
ret_oc <- xts(100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))), index(ts_close))
ret_cloise
ret_close
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", row.names = TRUE, col.names = TRUE)
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", col.names = TRUE)
## Make returns
## LOG return
ret_close <- momentum(100 * log(ts_close), n = 1)
ret_oc <- xts(100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))), index(ts_close))
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", col.names = TRUE)
write.zoo(ret_oc, file = "Open_to_close_log_returns.csv", col.names = TRUE)
ret_close <- read.csv("Close_to_close_log_returns.csv", row.names = )
ret_oc <- read.csv("Open_to_close_log_returns.csv")
ret_close
ret_close <- read.csv("Close_to_close_log_returns.csv", row.names = TRUE)
ret_close <- read.zoo("Close_to_close_log_returns.csv", row.names = TRUE)
ret_close <- read.zoo("Close_to_close_log_returns.csv")
ret_close <- read.zoo("Close_to_close_log_returns.csv", index.column = 1)
ret_close <- read.zoo("Close_to_close_log_returns.csv", index.column = Index)
fit
ret_close <- read.zoo("Close_to_close_log_returns.csv", row.names = TRUE)
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv", row.names = TRUE)
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv")
ret_close
str(ret_close)
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv", col.names = TRUE)
ret_close
ret_close[1:5]
ret_close <- read.zoo("Close_to_close_log_returns.csv", col.names = TRUE)
ret_close <- read.zoo("Close_to_close_log_returns.csv")
ret_close
ret_close <- read.csv("Close_to_close_log_returns.csv")
str(ret_close)
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ")
str(ret_close)
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ")
ret_oc
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = TRUE)
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = TRUE)
?read.csv
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", header = TRUE)
str(ret_close)
str(ret_close)
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = Index)
row.names(ret_close) <- ret_close$Index
ret_close
ret_close$Index <- NULL
ret_close
str(index(ret_close))
ret_close
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_close
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ", row.names = "Index")
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
ret_oc
index(ret_oc)
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", col.names = TRUE)
write.zoo(ret_oc, file = "Open_to_close_log_returns.csv", col.names = TRUE)
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ", row.names = "Index")
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
length(index(ret_oc))
length(ret_oc)
ret_oc
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_oc
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", col.names = TRUE)
write.zoo(ret_oc, file = "Open_to_close_log_returns.csv", col.names = TRUE)
ret_oc <- xts(100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))), index(ts_close))
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", col.names = TRUE)
write.zoo(ret_oc, file = "Open_to_close_log_returns.csv", col.names = TRUE)
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_oc
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
index(ret_oc)
## Make returns
## LOG return
ret_close <- momentum(100 * log(ts_close), n = 1)
ret_oc <- xts(100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))), index(ts_close))
ret_oc
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", col.names = TRUE)
write.zoo(ret_oc, file = "Open_to_close_log_returns.csv", col.names = TRUE)
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ", row.names = "Index")
plot(index(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
ret_oc
index(ret_oc)
index(ret_close)
str(ret_close)
row.names(ret_close)
plot(row.names(ret_open), ret_open, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(row.names(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
row.names(ret_open)
row.names(ret_open)
rownames(ret_open)
plot(row.names(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
row.names(ret_close)
ret_close
plot(row.names(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
length(row.names(ret_close))
length(ret_close)
plot(row.names(ret_close), ret_close$V1, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(row.names(ret_oc), ret_oc$V1, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
ret_close <- ts(read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index"))
ret_close
ret_close <- ts(ret_close$V1, row.names(ret_close))
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_close <- ts(ret_close$V1, row.names(ret_close))
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", col.names = TRUE)
write.zoo(ret_oc, file = "Open_to_close_log_returns.csv", col.names = TRUE)
## Make returns
## LOG return
ret_close <- momentum(100 * log(ts_close), n = 1)
ret_oc <- xts(100 *(as.numeric(log(ts_open)) - as.numeric(log(ts_close))), index(ts_close))
write.zoo(ret_close, file = "Close_to_close_log_returns.csv", col.names = TRUE)
write.zoo(ret_oc, file = "Open_to_close_log_returns.csv", col.names = TRUE)
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
glimpse(ret_close)
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv", sep = " ")
glimpse(ret_close)
ret_close
str(ret_close)
ret_close[1,]
ret_close[1:4]
plot(row.names(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
ret_oc
ret_close
ret_close
ret_oc
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ", row.names = "Index")
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
ret_oc <- read.csv.zoo("Open_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv", sep = " ")
ret_oc <- read.csv.zoo("Open_to_close_log_returns.csv", sep = " ")
ret_close <- ts(ret_close$V1, row.names(ret_close))
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
ret_oc <- read.csv.zoo("Open_to_close_log_returns.csv", sep = " ")
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
ret_oc
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
fit_ <- ugarchfit(spec, ret_close[2:length(ret_close)], solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)])
ret_close[2:5]
ret_close[2:10]
ret_oc[2:10]
kernel_cov
ret_close <- read.zoo("Close_to_close_log_returns.csv", sep = " ")
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv", sep = " ")
ret_oc <- read.csv.zoo("Open_to_close_log_returns.csv", sep = " ")
ret_close <- zoo_to_ts(read.csv.zoo("Close_to_close_log_returns.csv", sep = " "))
install.packages(TSstudio)
install.packages("TSstudio")
ret_close <- as.ts(read.csv.zoo("Close_to_close_log_returns.csv", sep = " "))
ret_close
str(ret_close)
ret_close <- as.ts(read.csv.zoo("Close_to_close_log_returns.csv", sep = " "))
ret_oc <- as.ts(read.csv.zoo("Open_to_close_log_returns.csv", sep = " "))
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv", sep = " ")
ret_oc <- read.csv.zoo("Open_to_close_log_returns.csv", sep = " ")
str(ret_oc)
ret_close <- ts(ret_close$Index, ret_close$Data)
ret_close <- ts(index(ret_close), ret_close)
ret_close[1:3]
ret_close <- ts(index(ret_close[2:length(ret_close)]), ret_close[2:length(ret_close)])
ret_close
ret_close <- ts(ret_close[2:length(ret_close)], index(ret_close[2:length(ret_close)]))
ret_close
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv", sep = " ")
ret_close <- ts(ret_close[2:length(ret_close)], index(ret_close[2:length(ret_close)]))
ret_close
str(ret_close)
ret_close <- read.csv.zoo("Close_to_close_log_returns.csv", sep = " ")
ret_close <- ts(ret_close[2:length(ret_close)], index(ret_close[2:length(ret_close)]))
str(ret_close)
ret_oc
values(ret_oc)
extract(ret_oc)
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ")
ret_close
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_close <- ts(ret_close[2:length(ret_close)]$, index(ret_close[2:length(ret_close)]))
ret_close <- ts(ret_close[2:length(ret_close)], index(ret_close[2:length(ret_close)]))
ret_close
ret_close <- ts(ret_close[2:length(ret_close)]$V1, index(ret_close[2:length(ret_close)]))
names(ret_close)
ret_close$V1
ret_close <- ts(ret_close$V1, index(ret_close[2:length(ret_close)]))
ret_close <- ts(ret_close$V1, index(ret_close))
ret_close
ret_close <- xts(ret_close$V1, index(ret_close))
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
ret_close <- xts(ret_close$V1, index(ret_close))
read.csv
index(ret_close) <- as.Date(ret_close,format="%Y-%m-%d %H:%M:%S")
index(ret_close) <- as.Date(index(ret_close),format="%Y-%m-%d %H:%M:%S")
row.names(ret_close) <- as.Date(index(ret_close),format="%Y-%m-%d %H:%M:%S")
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ", row.names = "Index")
row.names(ret_close) <- as.Date(index(ret_close),format="%Y-%m-%d %H:%M:%S")
ret_close
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ")
ret_close$Index <- as.Date(ret_close$Index,format="%Y-%m-%d %H:%M:%S")
ret_close
ret_close <- xts(ret_close$V1, ret_close$Index
ret_close <- xts(ret_close$V1, ret_close$Index)
ret_close <- xts(ret_close$V1, ret_close$Index)
ret_close
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ")
ret_oc$Index <- as.Date(ret_close$Index,format="%Y-%m-%d %H:%M:%S")
ret_oc <- xts(ret_close$V1, ret_close$Index)
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ")
ret_oc$Index <- as.Date(ret_oc$Index,format="%Y-%m-%d %H:%M:%S")
ret_oc <- xts(ret_close$V1, ret_close$Index)
ret_oc <- xts(ret_oc$V1, ret_oc$Index)
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ")
ret_close$Index <- as.Date(ret_close$Index,format="%Y-%m-%d %H:%M:%S")
ret_close <- xts(ret_close$V1, ret_close$Index)
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ")
ret_oc$Index <- as.Date(ret_oc$Index,format="%Y-%m-%d %H:%M:%S")
ret_oc <- xts(ret_oc$V1, ret_oc$Index)
ret_oc
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
fit_ <- ugarchfit(spec, ret_close[2:length(ret_close)], solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)])
print(fit)
kernel_cov
ret_close$Index <- as.POSIXct(ret_close$Index,format="%Y-%m-%d %H:%M:%S")
ret_close <- read.csv("Close_to_close_log_returns.csv", sep = " ")
ret_close$Index <- as.POSIXct(ret_close$Index,format="%Y-%m-%d %H:%M:%S")
ret_close <- xts(ret_close$V1, ret_close$Index)
ret_oc <- read.csv("Open_to_close_log_returns.csv", sep = " ")
ret_oc$Index <- as.POSIXct(ret_oc$Index,format="%Y-%m-%d %H:%M:%S")
ret_oc <- xts(ret_oc$V1, ret_oc$Index)
ret_oc
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
fit_ <- ugarchfit(spec, ret_close[2:length(ret_close)], solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)])
print(fit)
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
fit_ <- ugarchfit(spec, ret_close[2:length(ret_close)], solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)])
ret_close[1:5]
ret_close[2:5]
fit_ <- ugarchfit(spec, ret_close[2:length(ret_close)], solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)])
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 20, makeReturns = TRUE, kernelType = "Parzen")
warnings(0)
warnings()
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 5, makeReturns = TRUE, kernelType = "Parzen")
## Realized kernel estimator
kernel_cov <- rKernelCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 1, makeReturns = TRUE, kernelType = "Parzen")
## Realized volatility
cov <- rCov(ts, cor = FALSE, alignBy = "minutes", alignPeriod = 1, makeReturns = TRUE)
plot(index(ret_close), ret_close, type = "l", xlab = "Time", ylab = "Open to Close Log Return")
plot(index(ret_oc), ret_oc, type = "l", xlab = "Time", ylab = "Close to Close Log Return")
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), variance.model = list(model = 'realGARCH', garchOrder = c(1, 1)), distribution.model = "norm")
fit_ <- ugarchfit(spec, ret_close[2:length(ret_close)], solver = 'hybrid', realizedVol = kernel_cov[2:length(kernel_cov)])
print(fit)
